searchState.loadedDescShard("mannequin", 0, "About\nImplementation of a tree iteration with arena allocation\nDummy implementation of a rigid body used for testing\nThis module defines the flat, composable architecture for …\nDefines the payload carried by Nodelike in the context of …\nA node structure to be used in an arena allocated tree. …\nIterable tree that uses arena allocation.\nIterator for a depth-first iteration when the data is not …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContainer that holds data in a <code>TreeIterable</code>\nDefinition of the interfaces for tree iteration Order of …\nA datastructure to hold a tree hierarchy of data contained …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait representing a stateful forward kinematics algoritm. …\nTrait representing a stateful inverse kinematics algoritm.\nStruct for holding the composition of character animation …\nForward kinematics for the targets in <code>target_refs</code> and the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInverse kinematics for the targets in <code>target_refs</code> and the …\nTrait that adds an <code>accumulate</code> functions for accumulating …\ntypically joint positions (angles/extension), f64, [f64,3]\nVec, [f64;4], …\nA Rigid Body represents a single, rigid link connected to …\nE.g., 4x4 matrix, (3x1, 3x3), quaternions …\nHelper function to be used in std::iter::Scan for …\nConcat two transformations\n…\nTransform a point into the world coordinate system\nTransform a point into the local coordinate system\n…\nReturns the eutral element wrt. the transoformation …\nGet the Transformation from the parent taking the …")